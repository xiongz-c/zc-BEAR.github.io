---
layout: post
title: 第一次接触非线性结构——树的入门(一)
date: 2019-11-3
tag: algorithm
---

  期中考试时间为11月九号上午十点到十二点，考试内容为第一章到树讲完的内容。本章博客会在考试前一个星期持续更新，记录树结构的相关知识。

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### 树的基本概念与操作

 树是一种没有环的图。相比于诸如“树是一种形如树状的数据结构”之类的废话定义，我更喜欢这样定义树。虽然这不是一个准确定义树结构的方式，但是这说明了树的一些性质是和图有所关联的。在考虑树的一些问题时，往往与图的问题有一些相关性。同时，这也说明了，从树开始，我们就要不断地和递归、递归、递归打交道了。各种递归的方式将是我们遍历树图的工具，从这里走进树结构吧。

 树有一些基本的名词定义如下,来自[维基百科](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))：
>节点的度：一个节点含有的子树的个数称为该节点的度；

>树的度：一棵树中，最大的节点度称为树的度；

>叶节点或终端节点：度为零的节点；

>非终端节点或分支节点：度不为零的节点；

>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；

>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；

>兄弟节点：具有相同父节点的节点互称为兄弟节点；

>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；

>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；

>高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；

>堂兄弟节点：父节点在同一层的节点互为堂兄弟；

>节点的祖先：从根到该节点所经分支上的所有节点；

>子孙：以某节点为根的子树中任一节点都称为该节点的子孙；

>森林：由m（m>=0）棵互不相交的树的集合称为森林；

 以上是开始聊树结构之前必须知道的一些名词，至于其他各种各样奇形怪状的树名和性质就等到遇到了在慢慢了解吧。

#### 树的结构
 
 正如本文标题所说，树是我们接触到的第一种非线性的结构，因此构造树的节点的时候我们很容易联想到不久前学过的线性结构——链表。从链表的结构来推断，树的结构可以用如下代码表示

```cpp
struct node
{
	int val;
	node *leftchild = nullptr;
	node *rightchild = nullptr;
};
```

 这是一种比较典型的二叉树结构的C++描述，如果替换为有更多子节点的树，可以使用vector存取子节点，存取也方便。但是在实际的应用中，很多时候题目并不需要来构建一个树结构来解，像是作业中更多的时候是使用**array+vector**的形式模拟一个树的实现，就像之前在链表中实现的数组拟链一样。模拟出来的树和真实的树有所不一样的是，所有树的边两边的node都是等价的，即子节点也可以向上追溯到父节点的。这就在遍历的时候造成了一定的麻烦——区别这个节点究竟是父节点还是子节点，这就是我们要谈到的树的遍历。

#### 树的递归遍历：前后序

 **Attention：所有的递归都会用到大量的空间，在递归做题时注意是否爆了空间或者说开的栈的深度是否足够！**

 树的遍历是一种解题的手段，用不同的遍历方式可以以不同的顺序对节点进行操作，这是递归遍历的意义所在。而对于一般的树来说，遍历一般分为前序遍历后序遍历、深度优先遍历、广度优先遍历等(二叉树还拥有特殊作用的中序遍历，后面会提到)，其中比较简单的前序遍历后后序遍历即是在递归前和递归后对节点进行相应的操作，基本实现代码(以内容为整数为例)如下：

```cpp
void search(int fa, int me){
	//在这里进行操作即为前序遍历
	for(int e : v[me]){
		if(e != fa){
			search(me,i);
		}
	}
	//在这里进行操作即为后序遍历
}
```

 简单地理解一下前后序遍历的不同。其实他们访问节点的顺序是一样的，但是前序遍历是在访问到节点之后就立即进行操作，但后序遍历是一直向下找到尽头时才开始操作。如果把这个操作打印出来，就会体现为从上到下的遍历和从下到上的遍历之间的区别，具体的图片就先不贴了，写几遍去百度上找几篇博客对一下基本是没有什么问题的。那么这个遍历一般可以用于进行什么操作呢？作为基本的遍历形式，几乎所有的题目都会有相关这两种遍历形式的遍历。问题的关键是何时用哪一种顺序的遍历，这主要取决于你希望进行的操作是什么。

* 一般来说，当你计算一些值需要用到父节点的值时，就必须在递归下去之前先把这个值记录了才能做到累加，可惜暂时想不到什么例题。
* 同样的，如果你需要先得到子节点的值时你就不得不用后序遍历，如DSAA作业题中的Lab6_E，通过子树的红蓝点推断自己的红蓝点数量。

#### 树的递归遍历：魔改大法师

 DFS(深度优先遍历)，一个在JAVA1的作业和project中就用到的遍历算法，在DSAA中又被拿出来摩擦了一遍。希望这次自己有一个更深的理解。要想理解DFS，第一步就是摒弃死记硬背。DFS只是一种思想——向符合条件的位置进行递归搜索直到不符合为止。至于你在这个搜索的过程中干什么，都是属于可以自定义的部分。所以在DFS中，只要记住操作和递归条件自定义，就可以改出无数种适合题目的DFS方式，这里贴出一个作业题的深度优先搜索的正确代码。

```cpp
int find(int fa,int me, int cnt){
    cnt++;
    c[me] = cnt;
    if(nodes[me].empty())return cnt;
    int tmpC = cnt,mcnt = cnt;
    for(int i : nodes[me]){
        if(i!=fa){
            cnt = find(me,i,tmpC);
            if(cnt>mcnt){
                mcnt = cnt;
            }
        }
    }
    return mcnt;
}
```

 这是一种难度中等比较常见的深度搜索范例——在不知道子节点数量的情况下进行深度优先的查找。这里的深入条件就是只要有子节点就可以深入，但是只有子节点让cnt增加了才更新mcnt。可以看到这份代码并不是很优雅，因为对mcnt的更新完全没有必要，这里只要在递归的时候记录下每一个节点的深度，递归完成后做一个遍历，就可以找到最大深度，完全没必要绞尽脑汁去想怎么写才能返回最大的深度，如果要做出更改，大概就是这个样子：

```cpp
void find(int fa,int me, int cnt){
    cnt++;
    c[me] = cnt;
    if(nodes[me].empty())return ;
    for(int i : nodes[me]) if(i!=fa) find(me,i,cnt);
}
```

 这样就舒服多了，这也告诉我们，在进行DFS时，把精力放在可以搜索的**最宽松的条件**上，找最大值时可以通过各种条件筛选出符合条件的最大值，才是最优雅的深度优先搜索的实现，而不必要在思考如何正确地返回你想要的最大值上绞尽脑汁。

### 树的性质：直径、重心、等等

**求最短路径——树的直径的应用**
 
 先说说直径吧，在本次的作业题中出现了与树的直径相关的题目，而重心好像暂时还没有出现。用到了树的直径的题目是这次的bonus[K people travel on a tree](https://acm.sustech.edu.cn/onlinejudge/problem.php?cid=1058&pid=5)，简单描述一下题目：
 
 > 在n个城市中有k个朋友居住(k<=n)，他们希望有一天在一个城市聚会，而每移动一个城市的距离需要耗费一天的时间，如果他们想要在尽可能短的时间内到达聚会地点，需要多长时间？

 很典型的应用，找到一个城市离所有人都尽可能近。想法也很清晰：找到距离最远的两个人，然后把他们之间的距离除以二就是答案。这就转化成了这次我们要聊的树的性质——直径。

 > 在《算法导论》中，我们是这样定义直径的：树中所有最短路径的最大值即为树的直径。

 要想找到一棵树的直径，有很多种方法，在初次接触到这个概念的时候，我选择了一种比较简单的方法(**适用于边权非负的情况**)来理解记忆：任意选取一个点，用DFS找到离这个点最远的距离的点A，再从A出发，第二次使用DFS找到离A最远的点B，其中A和B的距离就是这棵树的直径。而针对这个题目，可以在DFS的条件设置为有子节点就继续找，然后把每一步的深度都记录下来。然后使用一个for循环遍历所有的节点，通过if(有朋友)来找到符合条件的最大值，可以减轻DFS的众多负担。为了避免歧义，这里上传这一题比较完整的代码：

```cpp
//这是递归的片段
void find(int fa,int me, int cnt){
    cnt++;
    c[me] = cnt;
    if(nodes[me].empty())return ;
    for(int i : nodes[me]) if(i!=fa) find(me,i,cnt);
}
//这是两次查找打印结果的代码片段
void result(){
    find(0,1,0);
    int minc = 0;
    for(int i = 0;i<=n;i++){
        if(c[i] > minc && city[i]==1){
            minc = c[i];
            mindex = i;
        }
    }
    find(0, mindex, 0);
    minCNT = 0;
    for(int i = 0;i<=n;i++){
        if(minCNT < c[i] && city[i] == 1 ){
            minCNT = c[i];
        }
    }
    cout<<minCNT/2<<endl;
}
```

 后面的部分就比较好理解了，总结来说这道题的考点就是翻译成找直径、找到合适的方法找直径、写出正确的DFS代码。但是既然讲到了树的直径这个属性，还是有必要证明一下这个方法的正确性的。因为是树的入门，这里只证明一种普通的情况：

> 定义：两点间的距离为这两点间的边权和，且边权和非负(这道题中一条边就是距离1)
> 采用反证法，假设第一次从aa开始找，找到的点是xx，而存在一个点uu使得以uu为根找最远点vv形成的直径要比以xx为根找最远点形成的直径长。假设两点间距离用|a,b|表示
>>如果(x,u)的路径与(u,v)的路径不相交，\|x,u\|+\|u,v\|一定比\|u,v\|长，假设不成立。
>>如果(x,u)的路径与(u,v)的路径相交，假设两路径的另一交点为y，那么\|x,y\|>\|u,y\|，因为以a为根时x的深度比u的深度深。

 这个反证法转载自网络，[该博主](https://www.cnblogs.com/Khada-Jhin/p/10195287.html)还讲解了其他几种直径定义下的证明，有兴趣的话可以直接去他的博客看看。

**得到最平衡的多个子树——被删去的重心**

 讲完了树的直径，接下来就是树的重心了。树的重心最基本的性质大概有以下三个：

* 对于一棵树来说，删去该树的重心后，所有的子树的大小不会超过原树大小的二分之一。
* 相对于树上的其他点而言，删去重心后形成的所有子树中最大的一棵节点数最少。换言之，删去重心得到的子树们是最平衡的。
* 一棵树的重心至多有两个。

 再往后的内容等我遇到了相关的题目有了更多感受再写，[参考博客](https://blog.csdn.net/zhanxufeng/article/details/80715185)