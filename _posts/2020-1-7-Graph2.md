---
layout: post
title: 初识图论(二)——最短路径、最小生成树、强连通分量
date: 2020-01-07
tag: algorithm
---

期末复习第二篇，总结DSAA的lab题目中出现过的几种算法，可能会在期末考试中出现。这一章做一个简单的梳理(~~写完这个我就可以去做cheatingpaper辣~~)

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### 小目录：记录这一章要讲些什么
 
* 有权图的最短路径算法
** dijkstra 单源有权图求最短路径（只能求无负权）
	松弛操作的意义
** Floyd-Warshall 解决任意两点间最短路径 （也不可算负权）
** Bellman-Ford 单源最短路（可以判断有无负权）
** SPFA 与上述算法的区别是维护了一个队列，减少了重复操作的次数。 
* 最小生成树/最大生成树
* tarjan
** tarjan应用1：判断是否强连通图（强连通分量是否有且仅只有一个）
** tarjan应用2：配合染色缩点
** 替换方案：两次DFS，适用于考试下——防止tarjan不给分/需要写出DFS过程的题目

### 图进阶：基本的图相关算法学习

在第二次的图作业中，我们主要涉及到了三个算法：dijkstra、最小生成树、tarjan。

#### 单源有权图(无负权)求最短路径

图论中很经典的问题就是求两个点之间的最短路径，针对已知出发点的问题，可以通过dijkstra算法求得图中的所有点距离该点的最短路径。dijkstra算法其实就是一个很简单的松弛操作：遍历优先队列的点，在每个点里遍历连向的NEXT向量，对每一个NEXT的点，利用“三角形三边关系”比较一下长短，更新路径长度，不断重复此过程直到遍历完全图。写成代码的形式大概是如下的样子：
```cpp
    dist[u] = 0;
    priority_queue<Node> q;
    q.push(Node{u,0});
    while (!q.empty())
    {
        now = q.top().index;q.pop();
       if(done[now])continue;
        done[now] = true;
        for(Node e : from[now])
        {
            int nxt = e.index;
            if(dist[nxt] > dist[now] + e.val)
            {
                dist[nxt] = dist[now] + e.val;
                q.push(Node{nxt,dist[nxt]});
            }9
        }
    }
```
以上是dijkstra的核心代码，不过在我们的作业题中还有一题([Lab9_E Portal](https://acm.sustech.edu.cn/onlinejudge/problem.php?cid=1061&pid=4))涉及到了分层图，面对分层图问题时我们可以考虑建立k倍大小的图进行dijkstra，这个题目也有可能在期末考试中出现，以下附上这题的源码：
```cpp
//省略一些头文件、常量及快读板子
struct Node{
    int index;
    ll val = INF;
    Node(int index,ll val){
        this->index = index;
        this->val = val;
    }
 
    bool operator < (const Node &x)const{
            return x.val < val;
    }
};
int n,m,p,k,u,v,now;
ll w;
bool done[MAXN*10];
ll dist[MAXN*10];
vector<Node> from[MAXN*11];
int main(){
    n = read();m = read();p = read();k = read();
    for (int i = 1; i < m+1;++i)
    {
        u = read();v = read();w = read();
        for (int j = 0; j <= k; ++j)
        {
            from[u+ n*j].emplace_back(v + n*j,w);
        }
    }
    for (int i = 0; i < p; ++i)
    {
        u = read();v = read();
        for (int j = 0; j < k; ++j)
        {
            from[u+ n*j].emplace_back(v + n*(j+1),0);
        }
    }
    u = read(),v = read();
    for (int i = 1; i <= n*10 ; ++i) {
        dist[i] = INF;
    }
    dist[u] = 0;
    priority_queue<Node> q;
    q.push(Node{u,0});
    while (!q.empty())
    {
        now = q.top().index;q.pop();
       if(done[now])continue;
        done[now] = true;
        for(Node e : from[now])
        {
            int nxt = e.index;
            if(dist[nxt] > dist[now] + e.val)
            {
                dist[nxt] = dist[now] + e.val;
                q.push(Node{nxt,dist[nxt]});
            }
        }
    }
    ll minLen = INF;
    for (int  j = 0 ; j<=k;  j++) {
        minLen = min(minLen,dist[v+j*n]);
    }
    printf("%lld",minLen);
    return 0;
}
```
