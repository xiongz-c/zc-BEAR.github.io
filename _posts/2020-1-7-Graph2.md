---
layout: post
title: 初识图论(二)——最短路径、最小生成树、强连通分量
date: 2020-01-07
tag: algorithm
---

期末复习第二篇，总结DSAA的lab题目中出现过的几种算法，可能会在期末考试中出现。这一章做一个简单的梳理(~~写完这个我就可以去做cheatingpaper辣~~)

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### 小目录：记录这一章要讲些什么

* 有权图的最短路径算法

> dijkstra 单源有权图求最短路径（只能求无负权）松弛操作的意义

> Floyd-Warshall 解决任意两点间最短路径 （也不可算负权）

> Bellman-Ford 单源最短路（可以判断有无负权）

> SPFA 与上述算法的区别是维护了一个队列，减少了重复操作的次数。 

* 最小生成树/最大生成树
* tarjan

> tarjan应用1：判断是否强连通图（强连通分量是否有且仅只有一个）

> tarjan应用2：配合染色缩点

> 替换方案：两次DFS，适用于考试下——防止tarjan不给分/需要写出DFS过程的题目

### 图进阶：基本的图相关算法学习

在第二次的图作业中，我们主要涉及到了三个算法：dijkstra、最小生成树、tarjan。

#### 单源有权图(无负权)求最短路径

图论中很经典的问题就是求两个点之间的最短路径，针对已知出发点的问题，可以通过dijkstra算法求得图中的所有点距离该点的最短路径。dijkstra算法其实就是一个很简单的松弛操作：遍历优先队列的点，在每个点里遍历连向的NEXT向量，对每一个NEXT的点，利用“三角形三边关系”比较一下长短，更新路径长度，不断重复此过程直到遍历完全图。写成代码的形式大概是如下的样子：
```cpp
    dist[u] = 0;
    priority_queue<Node> q;
    q.push(Node{u,0});
    while (!q.empty())
    {
        now = q.top().index;q.pop();
       if(done[now])continue;
        done[now] = true;
        for(Node e : from[now])
        {
            int nxt = e.index;
            if(dist[nxt] > dist[now] + e.val)
            {
                dist[nxt] = dist[now] + e.val;
                q.push(Node{nxt,dist[nxt]});
            }9
        }
    }
```
以上是dijkstra的核心代码，不过在我们的作业题中还有一题([Lab9_E Portal](https://acm.sustech.edu.cn/onlinejudge/problem.php?cid=1061&pid=4))涉及到了分层图，面对分层图问题时我们可以考虑建立k倍大小的图进行dijkstra，这个题目也有可能在期末考试中出现，以下附上这题的源码：
```cpp
//省略一些头文件、常量及快读板子
struct Node{
    int index;
    ll val = INF;
    Node(int index,ll val){
        this->index = index;
        this->val = val;
    }
 
    bool operator < (const Node &x)const{
            return x.val < val;
    }
};
int n,m,p,k,u,v,now;
ll w;
bool done[MAXN*10];
ll dist[MAXN*10];
vector<Node> from[MAXN*11];
int main(){
    n = read();m = read();p = read();k = read();
    for (int i = 1; i < m+1;++i)
    {
        u = read();v = read();w = read();
        for (int j = 0; j <= k; ++j)
        {
            from[u+ n*j].emplace_back(v + n*j,w);
        }
    }
    for (int i = 0; i < p; ++i)
    {
        u = read();v = read();
        for (int j = 0; j < k; ++j)
        {
            from[u+ n*j].emplace_back(v + n*(j+1),0);
        }
    }
    u = read(),v = read();
    for (int i = 1; i <= n*10 ; ++i) {
        dist[i] = INF;
    }
    dist[u] = 0;
    priority_queue<Node> q;
    q.push(Node{u,0});
    while (!q.empty())
    {
        now = q.top().index;q.pop();
       if(done[now])continue;
        done[now] = true;
        for(Node e : from[now])
        {
            int nxt = e.index;
            if(dist[nxt] > dist[now] + e.val)
            {
                dist[nxt] = dist[now] + e.val;
                q.push(Node{nxt,dist[nxt]});
            }
        }
    }
    ll minLen = INF;
    for (int  j = 0 ; j<=k;  j++) {
        minLen = min(minLen,dist[v+j*n]);
    }
    printf("%lld",minLen);
    return 0;
}
```
理解了思路dijkstra也就是五六行的事情，比较新颖的是分层图的做法，了解了分层图整个代码之后dijkstra可以说基本掌握了，下一部分是与此相似的最小生成树算法。

#### 最小/最大生成树

虽然标题是最小/最大生成树，但是其实这个部分的算法只有最小生成树，用脚趾头想想也知道，最大生成树其实只是最小生成树改一个比较条件而已。求出一个图中的最小生成树的两个基本算法是Kruskal和Prim算法。前者因为复杂度的分析比较复杂，我们仅作了解即可，后者是我们在课堂上教的方法，需要实现并分析其复杂度。这一部分主要讲Prim算法的一些细节。

根据算法导论上面的描述，Prim算法的思路是这样的：

> 随意选择一个起点，把这个根节点加进集合A中，算法的每一步在连接集合A和A之外的节点的所有边中，选择一条轻量级边加入到A中，这样每一次加入的都是一条安全边，保证了A中的边形成一棵最小生成树。本策略也属于**贪心策略**。

这样的描述比较直观，如果转化成伪代码的形式就是下面这样的(来自算法导论第三版)
```
MST-PRIM(G,w,r)
1. for each u $\in$ G.V
2.      u:key = $\infty$
3.      u:$\pi$ = $NIL$
4. r:key=0
5. Q = G.V
6. while Q &\neq& &\varnothing&
7.      u = EXTRACT-MIN(Q)
8.      for each v $\in$ G.Adj[u]
9.      if v $\in$ Q and w(u,v) < v.key
10.         v.$\pi$ = u
11.         v.key = w(u,v)
```