---
layout: post
title: DSAA第一次quiz的考前回顾
date: 2019-10-14 
tag: algorithm
---

 继上次写到排序和搜索算法之后，我开始意识到quiz的时间并没有那么早，于是又开了一篇文章来记录复习过程了。这次我们的主题是排序以后到quiz1之间的所有内容(其实就是这两个星期学的链表和堆栈)。

 话不多说，直接进入我们的正题吧

##### tips：虽然本人用JAVA熟练，但是考虑到算法题中大多使用C++来实现，并且我也在缓慢学习C++，这个标签下的代码都是C++代码。

### 链表：容易插入和删除元素却不容易查找的线性结构

  链表对我来说是一种很有感情的数据结构。为什么呢，因为这是我暑假期间还未接触数据结构时学长让我先去了解的一种最基础的数据结构，也在leetcode上面做了一点题目(然而做妮可oj的时候还是没能ak)。当然，暑假那强度并不大的练习主要是让我提升了一点Java的coding能力，让我在写代码这方面算是入门了。至于链表，只是了解了一下基础的单向链表结构，只能说是知道了他是个什么东西。

  作为复习，当然不会有老师的ppt那么详细的记录了。链表的插入、删除、交换等基本的操作还是参见老师的ppt吧。这里总结一下一些链表常见的考点吧。

#### 1. 链表基础操作的理解

  增减链表的结点，也就是那么几种操作，没有特别的技巧却需要比较扎实的基本功。所以在这个部分是最容易考察你是否注意到空指针异常的部分。

  在lab的练习中，第一题是多项式的加法，考虑的是把两个多项式存为数组，然后通过使用两个指针(下标)遍历数组就可以把数组的每个元素添加到最终的表达式(链表)中，这个过程主要是要考虑什么时候应该新建结点，什么时候对节点内部的数字进行相加。

  第二题思路更为清晰，只是把两段链表交换一下位置，这个时候就是要注意到在交换前要先用一个临时变量存一下不然会丢失地址。然后这题还涉及到一个双向指针的考点，在后面会再详细说到。

  至于其他的题目中再出现的基础操作也就无非这样了。这里要注意的考点就是要判断当前指针指向的是不是空，如果为空在向前向后查找的时候就会报空指针异常。
 
#### 2. 双向指针

 这是一个我之前一直没有注意到的操作。虽然教学中的例子都是单项指针，但是在实际的应用中单向的指针就是弟弟，在频繁出现的要往前查找的动作中，有一个前驱的指针是一个十分方便的事情，所以大部分时候记得要声明一个prev指针，并在构建链表的时候注意构建前后结点。

#### 3. 快慢指针

 一个在环形结构中有奇效的操作。在很多链表的题目中，会出现这些问题：如何判断一个链表有环；在一个有环的指针结构中怎么判断自己找到了最大/最小值。这些问题都可以用一个快慢指针来解决，只要有一个指针每次走两步，一个每次走一步，那当他们相遇的时候就是快指针比慢指针领先一个环的时候。同样的，类似于快慢指针的还有前后指针：让一个指针先走m步。这样的操作在有相关两个结点距离为m的题目中比较有效。

#### 4. 数组拟链

 严格来说这不算是一个考点，甚至是t老师非常鄙夷的一种行为。但是用数组的下标来记录数字，用数来记录前一个/后一个的数的方法在一些数字只会重复一次的题目中效率还是十分高的，也算是一种在写代码的过程中比较高效(加快时间/节省空间，代码量)的方式，属于coding技巧。在查找的方面也有得天独厚的优势。

 总的来说，链表只是一种比较中规中矩的数据结构，在练习的过程中对算法的要求不算太高，主要是要熟练一下链表的操作，对可能遇到的错误要有一定的判断，基本不是很大的问题。

### 栈和队列：基础且重点的巧妙结构

  栈和队列同样也是线性结构，可以说是本学期学到的最后一个线性结构了。他们的特点都是进行一些技巧性的操作后让我们需要的元素总在顶端，而访问顶端的元素只需要O(1)的时间，这就让很多利用这种结构完成的题目复杂度都在O(n)(每个元素只进出栈一次)。

##### tips：队列的头部是指出来的那一端（想象羽毛球筒子）

#### 栈和队列的几种形式和实现方式

  栈的结构中常用的有单调栈，队列有单调队列、双向队列、环形队列等等。本来应该在这里写到这些数据结构的实现细节，但是因为这样的讨论篇幅过长且有些啰嗦，数据结构的基本实现还是多参照课本和老师的课件吧，C++的标准库代码也是一个很不错的范例可供参考。以下就着重写这些结构应该在哪些地方运用了-，-。如果此时的你对栈和队列的基本结构还不甚熟悉，请先熟悉了他们的结构再继续向下阅读~

#### 单调队列/双向队列：灵活地找m长度的数中的最大值

  单调队列，顾名思义，就是从头到尾的数据有单调性的队列。典型的应用就是lab的c题，找长度为n的数中每m个数的最大值。如果维护一个双向的单调队列，就可以很方便地将最大值放在队头，然后在队尾添加元素的时候也很容易操作下标使得超出长度m的数字跳出队列。最后这个扫描就很显然是O(n)的，可以很高效地找到每个子列的最大值(最小值同理)。

#### 单调栈：方便地对左邻右舍做出判断

  单调栈，顾名思义，也是和单调队列一样需要维持栈的单调性。既然一个线性存储结构有单调性，就一定

#### 后缀表达式：对栈的深度了解

    

```C++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
int nums[MAXN], ans[MAXN];
void mergeSort(int l, int r) {
    if (l == r)return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = l;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j])ans[k++] = nums[i++];
        else ans[k++] = nums[j++];
    }
    while (i <= mid)ans[k++] = nums[i++];
    while (j <= r)ans[k++] = nums[j++];
    for (int x = l; x <= r; x++)nums[x] = ans[x];
}
```
  参考[移位运算符的百度百科](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348?fr=aladdin)。
