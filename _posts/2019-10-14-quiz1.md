---
layout: post
title: DSAA第一次quiz的考前回顾
date: 2019-10-14 
tag: algorithm
---

 继上次写到排序和搜索算法之后，我开始意识到quiz的时间并没有那么早，于是又开了一篇文章来记录复习过程了。这次我们的主题是排序以后到quiz1之间的所有内容(其实就是这两个星期学的链表和堆栈)。

 话不多说，直接进入我们的正题吧

##### tips：虽然本人用JAVA熟练，但是考虑到算法题中大多使用C++来实现，并且我也在缓慢学习C++，这个标签下的代码都是C++代码。

### 链表：容易插入和删除元素却不容易查找的线性结构

  链表对我来说是一种很有感情的数据结构。为什么呢，因为这是我暑假期间还未接触数据结构时学长让我先去了解的一种最基础的数据结构，也在leetcode上面做了一点题目(然而做妮可oj的时候还是没能ak)。当然，暑假那强度并不大的练习主要是让我提升了一点Java的coding能力，让我在写代码这方面算是入门了。至于链表，只是了解了一下基础的单向链表结构，只能说是知道了他是个什么东西。

  作为复习，当然不会有老师的ppt那么详细的记录了。链表的插入、删除、交换等基本的操作还是参见老师的ppt吧。这里总结一下一些链表常见的考点吧。

#### 1. 链表基础操作的理解

  增减链表的结点，也就是那么几种操作，没有特别的技巧却需要比较扎实的基本功。所以在这个部分是最容易考察你是否注意到空指针异常的部分。

  在lab的练习中，第一题是多项式的加法，考虑的是把两个多项式存为数组，然后通过使用两个指针(下标)遍历数组就可以把数组的每个元素添加到最终的表达式(链表)中，这个过程主要是要考虑什么时候应该新建结点，什么时候对节点内部的数字进行相加。

  第二题思路更为清晰，只是把两段链表交换一下位置，这个时候就是要注意到在交换前要先用一个临时变量存一下不然会丢失地址。然后这题还涉及到一个双向指针的考点，在后面会再详细说到。

  至于其他的题目中再出现的基础操作也就无非这样了。这里要注意的考点就是要判断当前指针指向的是不是空，如果为空在向前向后查找的时候就会报空指针异常。
 
#### 2. 双向指针

 这是一个我之前一直没有注意到的操作。虽然教学中的例子都是单项指针，但是在实际的应用中单向的指针就是弟弟，在频繁出现的要往前查找的动作中，有一个前驱的指针是一个十分方便的事情，所以大部分时候记得要声明一个prev指针，并在构建链表的时候注意构建前后结点。

#### 3. 快慢指针

 一个在环形结构中有奇效的操作。在很多链表的题目中，会出现这些问题：如何判断一个链表有环；在一个有环的指针结构中怎么判断自己找到了最大/最小值。这些问题都可以用一个快慢指针来解决，只要有一个指针每次走两步，一个每次走一步，那当他们相遇的时候就是快指针比慢指针领先一个环的时候。同样的，类似于快慢指针的还有前后指针：让一个指针先走m步。这样的操作在有相关两个结点距离为m的题目中比较有效。

#### 4. 数组拟链

 严格来说这不算是一个考点，甚至是t老师非常鄙夷的一种行为。但是用数组的下标来记录数字，用数来记录前一个/后一个的数的方法在一些数字只会重复一次的题目中效率还是十分高的，也算是一种在写代码的过程中比较高效(加快时间/节省空间，代码量)的方式，属于coding技巧。在查找的方面也有得天独厚的优势。

 总的来说，链表只是一种比较中规中矩的数据结构，在练习的过程中对算法的要求不算太高，主要是要熟练一下链表的操作，对可能遇到的错误要有一定的判断，基本不是很大的问题。

### 栈和队列：基础且重点的巧妙结构

  栈和队列同样也是线性结构，可以说是本学期学到的最后一个线性结构了。他们的特点都是进行一些技巧性的操作后让我们需要的元素总在顶端，而访问顶端的元素只需要O(1)的时间，这就让很多利用这种结构完成的题目复杂度都在O(n)(每个元素只进出栈一次)。

##### tips：队列的头部是指出来的那一端（想象羽毛球筒子）

#### 栈和队列的几种形式和实现方式

  栈的结构中常用的有单调栈，队列有单调队列、双向队列、环形队列等等。本来应该在这里写到这些数据结构的实现细节，但是因为这样的讨论篇幅过长且有些啰嗦，数据结构的基本实现还是多参照课本和老师的课件吧，C++的标准库代码也是一个很不错的范例可供参考。以下就着重写这些结构应该在哪些地方运用了-，-。如果此时的你对栈和队列的基本结构还不甚熟悉，请先熟悉了他们的结构再继续向下阅读~

#### 单调队列/双向队列：灵活地找m长度的数中的最大值

  单调队列，顾名思义，就是从头到尾的数据有单调性的队列。典型的应用就是lab的c题，找长度为n的数中每m个数的最大值。如果维护一个双向的单调队列，就可以很方便地将最大值放在队头，然后在队尾添加元素的时候也很容易操作下标使得超出长度m的数字跳出队列。最后这个扫描就很显然是O(n)的，可以很高效地找到每个子列的最大值(最小值同理)。

#### 单调栈：方便地对左邻右舍做出判断

  单调栈，顾名思义，也是和单调队列一样需要维持栈的单调性。既然一个线性存储结构有单调性，就一定有比较大小的能力。所以对于栈顶元素来说，可以很方便的与下一个目标比大小。同时，栈顶元素也具有“在栈中最小”的性质。可以用O(1)的操作来找到一个最小值。

  因为自己太菜了，没有很好的办法抽象出一个类型的题目，于是在这里就放下一个DSAA课程中的作业题[Magic Number](https://acm.sustech.edu.cn/onlinejudge/problem.php?cid=1056&pid=4)作为例题供参考吧！(~~我也不知道什么时候这个题目会被删库~~)

#### 后缀表达式：对栈的深度了解

  在复习栈的时候总是有种空中楼阁的感觉——形式巧妙却不知从何谈起应用。栈在很多地方都有很丰富的应用，但是由于现在的我学识尚浅，也没有见过太多的模板(~~作业太少~~)，就在这里详细地说一下后缀表达式吧。

  虽然不知道为啥这一届没有把手写后缀表达式作为一个考核的重点(可能会出现在期中期末？)，但是我认为这个操作绝对是在栈的学习中最最经典的一个部分。说来惭愧，在暑假用JAVA手撸了把中序表达式转换为后缀表达式的代码之后，在这次DSAA的作业中也没能完整地写完这个过程。简要说一下思路：

  > 每次读取一个中序表达式的字符，如果是数字可以直接放进结果，如果是符号/括号就进行分类讨论：
  * 遇到栈空时先把符号进栈
  * 该符号运算优先级大于栈顶元素就直接放在结果中；否则栈顶元素出栈且继续比对
  * 左括号进栈后相当于隔绝了左括号左边的操作，直到右括号出现，把两个括号之间的操作一次性吐完再接着操作。

  最后写成代码应该是下面这样的(留个坑，希望有空填上) 

```C++
#include <bits/stdc++.h>
using namespace std;
int main() 
{
    //这是个坑
    return 0;
}
```

  说完了这个中序到逆序的转换，接下来还有计算器的后半部分——计算逆序表达式。计算的过程比转换的过程轻松许多，但也是运用到了栈的知识的。

  > 遇到符号就进栈，直到符号后面跟着两个数字就消除符号和两个数字得到结果重新放回栈中，不断重复这个过程最后得到运算结果。

  代码依旧暂时留空


```C++
#include <bits/stdc++.h>
using namespace std;
int main() 
{
    //于是这是个坑
    return 0;
}
```
### 终于结束啦

  写到这里，栈和队列的介绍也基本上算是讲完了，其实写道这里的时候DSAA的quiz也考完接近一个星期了。因为考前任务过多的不可抗力没能完成这篇博客只能在周末补齐了。经过了这次的quiz之后我意识到最难完成的部分其实还是在考试的过程中想清楚二分搜索的种种条件，然后写出一个正确的二分搜索。成绩尚未出来但从整个班级只有不到1/10的同学能拿到70%的分数来看，我的分数想必也不会很好看吧。不过吃一堑长一智，这次的quiz中值得关注的地方就是二分搜索和最后一题的双指针判断回文序列(~~有时间再补上~~咕咕咕)。在以后的学习中，如果还有跟链表、栈和队列相关性比较大的内容我还会补充在这篇博客下，本节就到此为止啦！大家晚安！

  **下期预告：字符串的检索——KMP算法及相关扩展**