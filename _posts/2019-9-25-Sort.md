---
layout: post
title: 常见排序算法的优雅实现
date: 2019-09-25 
tag: algorithm
---

  新的学期开学啦，今天又是阳光明媚的一天。（小学生开场白...）临近国庆了，DSAA课程也进行了一个月。这个月的学习内容是查找，排序以及链表。这篇博客就简单总结一下我自己对归并排序和快排的理解，并记录一下一些排序的优雅实（ban）现（zi）。（实际上就是第一次quiz前临时抱佛脚的复习罢了）有时间的话就记录一下学习二分搜索时踩的坑，没时间就算了...

  开学时间紧张，不会投入太多的精力在更博上，这几个月主要的内容大概都是关于DSAA课程中一些简单算法学习过程的记录。尽量做到月更吧，偶尔有时间补充一些新奇有趣的其他知识（又给自己挖个大坑）。那么废话少说，进入今天的主题——排序算法吧。

##### tips：虽然本人用JAVA熟练，但是考虑到算法题中大多使用C++来实现，并且我也在缓慢学习C++，这个标签下的代码都是C++代码。

### 普普通通的冒泡/选择/插入排序

  这是三种最简单的排序，也很容易理解，但是缺点就是时间复杂度高达O(n<sup>2</sup>),在对时间要求较高的题目中就容易超时。这也不是这篇博客的重点，也就不贴代码了。可以用来在刚接触某门语言的时候练习coding能力。

### 归并排序：分治思想的运用，稳定的nlongn排序
  对于归并算法的理解就是把一个数组分成两半，再对这两半分别进行归并排序，排成有序的两个子列后合并为一个数组。因此，就是把这个归并的过程不断递归到只有两个数的情况，再逐层合并，最终合成我们需要的子列。

  在这个过程中，我了解到的归并实现大概可以分成两种：

  一是每一层的递归都新建一个数组对象，这样的好处是容易理解，每一层都有两个新建的数组对象来存储所需要的数据，然后再这一层结束之前清除这两个数组的内存空间（C++需要手动清除，Java有垃圾回收机制）。所以坏处也是显而易见的，每次创造数组都要开辟一定的空间，而上层的数组要等下层完成归并才能结束方法并清除空间，会造成很大的空间浪费。同时，新建对象的过程同样也是十分消耗时间的，特别是用C++完成作业时这样的操作显得过于奢侈。

  第二种就是不新建对象的写法，显然，这种写法的好处就是与上一种中写法的缺点相对应的，理解起来也不会太困难，但是就要摆脱上一种方法里用数组记录每一步状态的思维惯性。废话少说，以下是这种写法对应的C++代码，代码的原型来自于洛谷某题的题解，侵删~
```bash
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
int nums[MAXN], ans[MAXN];
void mergeSort(int l, int r) {
    if (l == r)return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = l;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j])ans[k++] = nums[i++];
        else ans[k++] = nums[j++];
    }
    while (i <= mid)ans[k++] = nums[i++];
    while (j <= r)ans[k++] = nums[j++];
    for (int x = l; x <= r; x++)nums[x] = ans[x];
}
```
  可以明显看出，这中写法用于避免每一步都要新建数组的方式就是先进入下一步的方法里（即把排序的部分后置），然后利用下标来操作数组保证要操作的数组是原数组的某个区间段，从而达到互不影响的效果。第一次看可能会比较懵，多理解几遍就会发现这样的写法很自然~

##### tips:我也是通过这段代码接触C++中利用下标控制数组片段来使用的思想。

### 快排：平均复杂度和归并排序一致，但是实际完全可以更快的看脸排序法

  首先说一下快排的思想：通过构造左右两个序列，左边的序列关键字都小于右边的序列，然后分别对左右进行排序最终达成排好序的目的——也是分支思想的体现。

  现在写下这段文字的我还是对快排没有完全理解（就会抄抄板子的样子）的小萌新，所以就先贴出一段来自《代码之美》的令人惊叹的优雅快排实现吧~

```bash 
#include<iostream>
#include<cstdlib>
#include<time.h>
using namespace std;
void swap(const int a,const int b,int x[])
{
  int temp = x[a];
  x[a] = x[b];
  x[b] = temp;
}
void quicksort(int l, int u, int x[])//1.386nlgn 实际是二分搜索树
{
  int i, m;
  if (l >= u)return;
  swap(l, (rand() % (u - l + 1) + l),x);
  m = l;
  for (i = l + 1; i <= u; i++)
    if (x[i] < x[l])swap(++m, i, x);
  swap(l, m, x);
  quicksort(l, m - 1, x);
  quicksort(m + 1, u, x);
}
int main() {
  srand(time(0));
  int x[100];
  int p = 10;
  for (int i = 0; i < p; i++)cin >> x[i];
  quicksort(0, p-1, x);
  for (int i = 0; i <p; i++)cout << x[i] << endl;
}
```
 贴完代码的n天后~终于可以解释一下这段代码了，其中只有quicksort的方法才是快排的核心代码，可以看到这里用九行就实现了一个快排（我都吓傻了）。

 第一行的声明和第二行的常规终止条件（左边大就终止）没什么好说的。

 第三行是一个交换位置，即把第一个数和序列中随机的一个数交换位置（即把随机的一个数放到l的位置上），下面就可以解释为啥这样做。

 第四五行就是让m从l的位置上开始，i从l+1的位置上开始往右走。注意到判断的条件是第i个和第l个比较，就是第i个和刚刚选出来的那个天选之子的比较。这样做的目的就是让下标m总是走的比i慢一点，而满的个数刚好就是i没有比天选之子小的位数。

 第六行的一个交换操作就让天选之子回到了他的位置（刚好就是m，左边都是比他小的，右边都是比他大的）。

 七八行就是对左右进行同样的递归操作，最终实现整个序列的有序。

 排序算法有很多，而一些经典的排序也是数据结构与算法设计课程中的基本知识。限于课时所限，妮可在DSAA上暂且就讲了上述五种算法。其中前三种是相对效率低下的算法，现在一般不会使用。后两种是速度比较快的两种算法，归并算法的特点是稳定而快排的速度与运气有关，但一般来说快排会比归并要快上一点。背下这两套排序的板子将有助于在这门课的考试中取得一个好成绩！另附上一个[讲解十大经典排序的网页](https://www.cnblogs.com/onepixel/p/7674659.html)，该网站的代码似乎不太容易理解，但是动图演示和远离讲解都讲得蛮不错的，可以作为经典排序算法的完整补充！排序的部分就到此结束辣！

 ### 二分查找n种写法：背下一种就可以！
