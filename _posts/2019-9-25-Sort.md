---
layout: post
title: 常见排序算法的优雅实现
date: 2019-09-25 
tag: algorithm
---

  新的学期开学啦，今天又是阳光明媚的一天。（小学生开场白...）临近国庆了，DSAA课程也进行了一个月。这个月的学习内容是查找，排序以及链表。这篇博客就简单总结一下我自己对归并排序和快排的理解，并记录一下一些排序的优雅实（ban）现（zi）。（实际上就是第一次quiz前临时抱佛脚的复习罢了）有时间的话就记录一下学习二分搜索时踩的坑，没时间就算了...

  开学时间紧张，不会投入太多的精力在更博上，这几个月主要的内容大概都是关于DSAA课程中一些简单算法学习过程的记录。尽量做到月更吧，偶尔有时间补充一些新奇有趣的其他知识（又给自己挖个大坑）。那么废话少说，进入今天的主题——排序算法吧。

##### tips：虽然本人用JAVA熟练，但是考虑到算法题中大多使用C++来实现，并且我也在缓慢学习C++，这个标签下的代码都是C++代码。

### 普普通通的冒泡/选择/插入排序

  这是三种最简单的排序，也很容易理解，但是缺点就是时间复杂度高达O(n<sup>2</sup>),在对时间要求较高的题目中就容易超时。这也不是这篇博客的重点，也就不贴代码了。可以用来在刚接触某门语言的时候练习coding能力。

### 归并排序：分治思想的运用，稳定的nlogn排序
  对于归并算法的理解就是把一个数组分成两半，再对这两半分别进行归并排序，排成有序的两个子列后合并为一个数组。因此，就是把这个归并的过程不断递归到只有两个数的情况，再逐层合并，最终合成我们需要的子列。

  在这个过程中，我了解到的归并实现大概可以分成两种：

  一是每一层的递归都新建一个数组对象，这样的好处是容易理解，每一层都有两个新建的数组对象来存储所需要的数据，然后再这一层结束之前清除这两个数组的内存空间（C++需要手动清除，Java有垃圾回收机制）。所以坏处也是显而易见的，每次创造数组都要开辟一定的空间，而上层的数组要等下层完成归并才能结束方法并清除空间，会造成很大的空间浪费。同时，新建对象的过程同样也是十分消耗时间的，特别是用C++完成作业时这样的操作显得过于奢侈。

  第二种就是不新建对象的写法，显然，这种写法的好处就是与上一种中写法的缺点相对应的，理解起来也不会太困难，但是就要摆脱上一种方法里用数组记录每一步状态的思维惯性。废话少说，以下是这种写法对应的C++代码，代码的原型来自于洛谷某题的题解，侵删~
```bash
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
int nums[MAXN], ans[MAXN];
void mergeSort(int l, int r) {
    if (l == r)return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = l;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j])ans[k++] = nums[i++];
        else ans[k++] = nums[j++];
    }
    while (i <= mid)ans[k++] = nums[i++];
    while (j <= r)ans[k++] = nums[j++];
    for (int x = l; x <= r; x++)nums[x] = ans[x];
}
```
  可以明显看出，这中写法用于避免每一步都要新建数组的方式就是先进入下一步的方法里（即把排序的部分后置），然后利用下标来操作数组保证要操作的数组是原数组的某个区间段，从而达到互不影响的效果。第一次看可能会比较懵，多理解几遍就会发现这样的写法很自然~

##### tips:我也是通过这段代码接触C++中利用下标控制数组片段来使用的思想。

### 快排：平均复杂度和归并排序一致，但是实际完全可以更快的看脸排序法

  首先说一下快排的思想：通过构造左右两个序列，左边的序列关键字都小于右边的序列，然后分别对左右进行排序最终达成排好序的目的——也是分支思想的体现。

  现在写下这段文字的我还是对快排没有完全理解（就会抄抄板子的样子）的小萌新，所以就先贴出一段来自《代码之美》的令人惊叹的优雅快排实现吧~

```bash 
#include<iostream>
#include<cstdlib>
#include<time.h>
using namespace std;
void swap(const int a,const int b,int x[])
{
  int temp = x[a];
  x[a] = x[b];
  x[b] = temp;
}
void quicksort(int l, int u, int x[])//1.386nlgn 实际是二分搜索树
{
  int i, m;
  if (l >= u)return;
  swap(l, (rand() % (u - l + 1) + l),x);
  m = l;
  for (i = l + 1; i <= u; i++)
    if (x[i] < x[l])swap(++m, i, x);
  swap(l, m, x);
  quicksort(l, m - 1, x);
  quicksort(m + 1, u, x);
}
int main() {
  srand(time(0));
  int x[100];
  int p = 10;
  for (int i = 0; i < p; i++)cin >> x[i];
  quicksort(0, p-1, x);
  for (int i = 0; i <p; i++)cout << x[i] << endl;
}
```
 贴完代码的n天后~终于可以解释一下这段代码了，其中只有quicksort的方法才是快排的核心代码，可以看到这里用九行就实现了一个快排（我都吓傻了）。

 第一行的声明和第二行的常规终止条件（左边大就终止）没什么好说的。

 第三行是一个交换位置，即把第一个数和序列中随机的一个数交换位置（即把随机的一个数放到l的位置上），下面就可以解释为啥这样做。

 第四五行就是让m从l的位置上开始，i从l+1的位置上开始往右走。注意到判断的条件是第i个和第l个比较，就是第i个和刚刚选出来的那个天选之子的比较。这样做的目的就是让下标m总是走的比i慢一点，而满的个数刚好就是i没有比天选之子小的位数。

 第六行的一个交换操作就让天选之子回到了他的位置（刚好就是m，左边都是比他小的，右边都是比他大的）。

 七八行就是对左右进行同样的递归操作，最终实现整个序列的有序。

 排序算法有很多，而一些经典的排序也是数据结构与算法设计课程中的基本知识。限于课时所限，妮可在DSAA上暂且就讲了上述五种算法。其中前三种是相对效率低下的算法，现在一般不会使用。后两种是速度比较快的两种算法，归并算法的特点是稳定而快排的速度与运气有关，但一般来说快排会比归并要快上一点。背下这两套排序的板子将有助于在这门课的考试中取得一个好成绩！另附上一个[讲解十大经典排序的网页](https://www.cnblogs.com/onepixel/p/7674659.html)，该网站的代码似乎不太容易理解，但是动图演示和远离讲解都讲得蛮不错的，可以作为经典排序算法的完整补充！排序的部分就到此结束辣！

### 二分查找n种写法：多总结，不同情况不同写法！

二分搜索有很长的历史，也是数据结构必修的一个经典搜索算法，他的时间复杂度为O(logn)。二分搜索的思路很简单，就不阐述了，但是他的实现确实一件令人头疼的事情，大多数程序员可能现在依然会写出有bug的二分搜索。

二分搜索的实现一般有用递归和while循环两种，但是因为栈的深度问题，我们一般不推荐使用递归进行二分查找。这里贴出一份很经典的二分搜索算法，他大体上没有问题，但是在一些细节上仍然有bug，而这个bug是经过了许多年才被发现的。
```bash
public static int binarySearch(int[] a, int target) { 
     int low = 0; 
     int high = a.length - 1; 
 
     while (low <= high) 
     { 
         int mid = (low + high) / 2; 
         int midVal = a[mid]; 
 
         if (midVal < target) 
             low = mid + 1; 
         else if (midVal > target) 
             high = mid - 1; 
         else 
             return mid; 
     } 
```
如果你有着丰富的编程经验，一定一眼就可以看出来这个代码有一个不妥当的地方，令你感到不安。没错，就是这一行。
```bash
    int mid = (low + high) / 2;
```
low和high作为两个中间变量取值范围都在int内，但是只要他们稍大一些，他们相加的结果一定会超出int类型的数据，于是我们要对他稍作改动。
```bash
    int mid = low + (high - low) / 2 ;
```
显然，从这个变化我们可以得出一个结论：在加减法之间优先使用减法在某些情况下可以使你的代码更安全。但不得不说一句，这样的写法虽然在算式上让人容易理解，但是代码的美观性确实不咋样，于是作死的程序员们想到了一个更好看的写法。
```bash
    int mid = (low + high) >>> 1 ;
```
哈！如果你不熟悉程序中的位运算(像初学dsaa的我一样)，就会对这个代码一头雾水。是的，这个代码虽然短，但是并不是所有程序员都能一眼看出他在做什么的，这里的操作实际上是对前面加法的结果的二进制表示向右移动了一位（这实际上就相当于把十进制数除以二了），因为是直接对二进制进行操作，就免去了作除法时数据类型转换出现的bug，同时在计算机的操作中，直接对二进制进行操作显然也是一种更节省时间和内存的方式，这是一种更优的写法。当然，贴出这种写法的目的还有一个：对位移运算符作一些简单的了解，具体的解释可以参考[移位运算符的百度百科](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348?fr=aladdin)。


