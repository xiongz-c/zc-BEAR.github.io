---
layout: post
title: 常见排序算法的优雅实现
date: 2019-09-25 
tag: algorithm
---

  新的学期开学啦，今天又是阳光明媚的一天。（小学生开场白...）临近国庆了，DSAA课程也进行了一个月。这个月的学习内容是查找，排序以及链表。这篇博客就简单总结一下我自己对归并排序和快排的理解，并记录一下一些排序的优雅实（ban）现（zi）。有时间的话就记录一下学习二分搜索时踩的坑，没时间就算了...

  开学时间紧张，不会投入太多的精力在更博上，这几个月主要的内容大概都是关于DSAA课程中一些简单算法学习过程的记录。尽量做到月更吧，偶尔有时间补充一些新奇有趣的其他知识（又给自己挖个大坑）。那么废话少说，进入今天的主题————排序算法吧。

##### tips：虽然本人对JAVA更为熟练，但是考虑到算法题中大多是使用C++来实现的并且我也在缓慢学习C++的道路之中，这个标签下的绝大多数代码都是C++的代码。

### 普普通通的冒泡/选择/插入排序

  这是三种最简单的排序，也很容易理解，但是缺点就是时间复杂度高达O(n<sup>2</sup>),在对时间要求较高的题目中就容易超时。这也不是这篇博客的重点，也就不贴代码了。可以用来在刚接触某门语言的时候练习coding能力。

### 归并排序：分治思想的运用，稳定的nlongn排序
  对于归并算法的理解就是把一个数组分成两半，再对这两半分别进行归并排序，排成有序的两个子列后合并为一个数组。因此，就是把这个归并的过程不断递归到只有两个数的情况，再逐层合并，最终合成我们需要的子列。

  在这个过程中，我了解到的归并实现大概可以分成两种：

  一是每一层的递归都新建一个数组对象，这样的好处是容易理解，每一层都有两个新建的数组对象来存储所需要的数据，然后再这一层结束之前清除这两个数组的内存空间（C++需要手动清除，Java有垃圾回收机制）。所以坏处也是显而易见的，每次创造数组都要开辟一定的空间，而上层的数组要等下层完成归并才能结束方法并清除空间，会造成很大的空间浪费。同时，新建对象的过程同样也是十分消耗时间的，特别是用C++完成作业时这样的操作显得过于奢侈。

  第二种就是不新建对象的写法，显然，这种写法的好处就是与上一种中写法的缺点相对应的，理解起来也不会太困难，但是就要摆脱上一种方法里用数组记录每一步状态的思维惯性。废话少说，以下是这种写法对应的C++代码，代码的原型来自于洛谷某题的题解，侵删~
```bash
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
int nums[MAXN], ans[MAXN];
void mergeSort(int l, int r) {
    if (l == r)return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = l;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j])ans[k++] = nums[i++];
        else ans[k++] = nums[j++];
    }
    while (i <= mid)ans[k++] = nums[i++];
    while (j <= r)ans[k++] = nums[j++];
    for (int x = l; x <= r; x++)nums[x] = ans[x];
}
```
  可以明显看出，这中写法用于避免每一步都要新建数组的方式就是先进入下一步的方法里（即把排序的部分后置），然后利用下标来操作数组保证要操作的数组是原数组的某个区间段，从而达到互不影响的效果。第一次看可能会比较懵，多理解几遍就会发现这样的写法很自然~

##### tips:我也是通过这段代码接触C++中利用下标控制数组片段来使用的思想。

### 快排：平均复杂度和归并排序一致，但是实际完全可以更快的看脸排序法

  现在写下这段文字的我还是对快排没有完全理解（就会抄抄板子的样子）的小萌新，所以就先贴出一段来自《代码之美》的令人惊叹的优雅快排实现吧~

```bash 
#include<iostream>
#include<cstdlib>
#include<time.h>
using namespace std;
void swap(const int a,const int b,int x[])
{
  int temp = x[a];
  x[a] = x[b];
  x[b] = temp;
}
void quicksort(int l, int u, int x[])//1.386nlgn 实际是二分搜索树
{
  
  int i, m;
  if (l >= u)return;
  swap(l, (rand() % (u - l + 1) + l),x);
  m = l;
  for (i = l + 1; i <= u; i++)
    if (x[i] < x[l])swap(++m, i, x);
  swap(l, m, x);
  quicksort(l, m - 1, x);
  quicksort(m + 1, u, x);
}
int main() {
  srand(time(0));
  int x[100];
  int p = 10;
  for (int i = 0; i < p; i++)cin >> x[i];
  quicksort(0, p-1, x);
  for (int i = 0; i <p; i++)cout << x[i] << endl;
}
```

