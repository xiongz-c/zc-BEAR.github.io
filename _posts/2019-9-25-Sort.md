---
layout: post
title: 常见排序算法的优雅实现
date: 2019-09-25 
tag: algorithm
---

  新的学期开学啦，今天又是阳光明媚的一天。（小学生开场白...）临近国庆了，DSAA课程也进行了一个月。这个月的学习内容是查找，排序以及链表。这篇博客就简单总结一下我自己对归并排序和快排的理解，并记录一下一些排序的优雅实（ban）现（zi）。（实际上就是第一次quiz前临时抱佛脚的复习罢了）有时间的话就记录一下学习二分搜索时踩的坑，没时间就算了...

  开学时间紧张，不会投入太多的精力在更博上，这几个月主要的内容大概都是关于DSAA课程中一些简单算法学习过程的记录。尽量做到月更吧，偶尔有时间补充一些新奇有趣的其他知识（又给自己挖个大坑）。那么废话少说，进入今天的主题——排序算法吧。

##### tips：虽然本人用JAVA熟练，但是考虑到算法题中大多使用C++来实现，并且我也在缓慢学习C++，这个标签下的代码都是C++代码。

### 普普通通的冒泡/选择/插入排序

  这是三种最简单的排序，也很容易理解，但是缺点就是时间复杂度高达O(n<sup>2</sup>),在对时间要求较高的题目中就容易超时。这也不是这篇博客的重点，也就不贴代码了。可以用来在刚接触某门语言的时候练习coding能力。

### 归并排序：分治思想的运用，稳定的nlogn排序
  对于归并算法的理解就是把一个数组分成两半，再对这两半分别进行归并排序，排成有序的两个子列后合并为一个数组。因此，就是把这个归并的过程不断递归到只有两个数的情况，再逐层合并，最终合成我们需要的子列。

  在这个过程中，我了解到的归并实现大概可以分成两种：

  一是每一层的递归都新建一个数组对象，这样的好处是容易理解，每一层都有两个新建的数组对象来存储所需要的数据，然后再这一层结束之前清除这两个数组的内存空间（C++需要手动清除，Java有垃圾回收机制）。所以坏处也是显而易见的，每次创造数组都要开辟一定的空间，而上层的数组要等下层完成归并才能结束方法并清除空间，会造成很大的空间浪费。同时，新建对象的过程同样也是十分消耗时间的，特别是用C++完成作业时这样的操作显得过于奢侈。

  第二种就是不新建对象的写法，显然，这种写法的好处就是与上一种中写法的缺点相对应的，理解起来也不会太困难，但是就要摆脱上一种方法里用数组记录每一步状态的思维惯性。废话少说，以下是这种写法对应的C++代码，代码的原型来自于洛谷某题的题解，侵删~
```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 1e6 + 10;
int nums[MAXN], ans[MAXN];
void mergeSort(int l, int r) {
    if (l == r)return;
    int mid = (l + r) / 2, i = l, j = mid + 1, k = l;
    mergeSort(l, mid);
    mergeSort(mid + 1, r);
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j])ans[k++] = nums[i++];
        else ans[k++] = nums[j++];
    }
    while (i <= mid)ans[k++] = nums[i++];
    while (j <= r)ans[k++] = nums[j++];
    for (int x = l; x <= r; x++)nums[x] = ans[x];
}
```
  可以明显看出，这种写法用于避免每一步都要新建数组的方式就是先进入下一步的方法里（即把排序的部分后置），然后利用下标来操作数组保证要操作的数组是原数组的某个区间段，从而达到互不影响的效果。第一次看可能会比较懵，多理解几遍就会发现这样的写法很自然~

##### tips:我也是通过这段代码接触C++中利用下标控制数组片段来使用的思想。

### 快排：平均复杂度和归并排序一致，但是实际完全可以更快的看脸排序法

  首先说一下快排的思想：通过构造左右两个序列，左边的序列关键字都小于右边的序列，然后分别对左右进行排序最终达成排好序的目的——也是分支思想的体现。

  现在写下这段文字的我还是对快排没有完全理解（就会抄抄板子的样子）的小萌新，所以就先贴出一段来自《代码之美》的令人惊叹的优雅快排实现吧~

```c++ 
#include<iostream>
#include<cstdlib>
#include<time.h>
using namespace std;
void swap(const int a,const int b,int x[])
{
  int temp = x[a];
  x[a] = x[b];
  x[b] = temp;
}
void quicksort(int l, int u, int x[])//1.386nlgn 实际是二分搜索树
{
  int i, m;
  if (l >= u)return;
  swap(l, (rand() % (u - l + 1) + l),x);
  m = l;
  for (i = l + 1; i <= u; i++)
    if (x[i] < x[l])swap(++m, i, x);
  swap(l, m, x);
  quicksort(l, m - 1, x);
  quicksort(m + 1, u, x);
}
int main() {
  srand(time(0));
  int x[100];
  int p = 10;
  for (int i = 0; i < p; i++)cin >> x[i];
  quicksort(0, p-1, x);
  for (int i = 0; i <p; i++)cout << x[i] << endl;
}
```
 贴完代码的n天后~终于可以解释一下这段代码了，其中只有quicksort的方法才是快排的核心代码，可以看到这里用九行就实现了一个快排（我都吓傻了）。

 第一行的声明和第二行的常规终止条件（左边大就终止）没什么好说的。

 第三行是一个交换位置，即把第一个数和序列中随机的一个数交换位置（即把随机的一个数放到l的位置上），下面就可以解释为啥这样做。

 第四五行就是让m从l的位置上开始，i从l+1的位置上开始往右走。注意到判断的条件是第i个和第l个比较，就是第i个和刚刚选出来的那个天选之子的比较。这样做的目的就是让下标m总是走的比i慢一点，而满的个数刚好就是i没有比天选之子小的位数。

 第六行的一个交换操作就让天选之子回到了他的位置（刚好就是m，左边都是比他小的，右边都是比他大的）。

 七八行就是对左右进行同样的递归操作，最终实现整个序列的有序。

 排序算法有很多，而一些经典的排序也是数据结构与算法设计课程中的基本知识。限于课时所限，妮可在DSAA上暂且就讲了上述五种算法。其中前三种是相对效率低下的算法，现在一般不会使用。后两种是速度比较快的两种算法，归并算法的特点是稳定而快排的速度与运气有关，但一般来说快排会比归并要快上一点。背下这两套排序的板子将有助于在这门课的考试中取得一个好成绩！另附上一个[讲解十大经典排序的网页](https://www.cnblogs.com/onepixel/p/7674659.html)，该网站的代码似乎不太容易理解，但是动图演示和远离讲解都讲得蛮不错的，可以作为经典排序算法的完整补充！排序的部分就到此结束辣！

### 二分查找n种写法：多总结，不同情况不同写法！

二分搜索有很长的历史，也是数据结构必修的一个经典搜索算法，他的时间复杂度为O(logn)。二分搜索的思路很简单，就不阐述了，但是他的实现确实一件令人头疼的事情，大多数程序员可能现在依然会写出有bug的二分搜索。

二分搜索的实现一般有用递归和while循环两种，但是因为栈的深度问题，我们一般不推荐使用递归进行二分查找。这里贴出一份很经典的二分搜索算法，他大体上没有问题，但是在一些细节上仍然有bug，而这个bug是经过了许多年才被发现的。
```c++
public static int binarySearch(int[] a, int target) { 
     int low = 0; 
     int high = a.length - 1; 
 
     while (low <= high) 
     { 
         int mid = (low + high) / 2; 
         int midVal = a[mid]; 
 
         if (midVal < target) 
             low = mid + 1; 
         else if (midVal > target) 
             high = mid - 1; 
         else 
             return mid; 
     } 
```
如果你有着丰富的编程经验，一定一眼就可以看出来这个代码有一个不妥当的地方，令你感到不安。没错，就是这一行。
```c++
    int mid = (low + high) / 2;
```
low和high作为两个中间变量取值范围都在int内，但是只要他们稍大一些，他们相加的结果一定会超出int类型的数据，于是我们要对他稍作改动。
```c++
    int mid = low + (high - low) / 2 ;
```
显然，从这个变化我们可以得出一个结论：在加减法之间优先使用减法在某些情况下可以使你的代码更安全。但不得不说一句，这样的写法虽然在算式上让人容易理解，但是代码的美观性确实不咋样，于是作死的程序员们想到了一个更好看的写法。
```c++
    int mid = (low + high) >>> 1 ;
```
 哈！如果你不熟悉程序中的位运算(像初学dsaa的我一样)，就会对这个代码一头雾水。是的，这个代码虽然短，但是并不是所有程序员都能一眼看出他在做什么的，这里的操作实际上是对前面加法的结果的二进制表示向右移动了一位（这实际上就相当于把十进制数除以二了），因为是直接对二进制进行操作，就免去了作除法时数据类型转换出现的bug，同时在计算机的操作中，直接对二进制进行操作显然也是一种更节省时间和内存的方式，这是一种更优的写法。当然，贴出这种写法的目的还有一个：对位移运算符作一些简单的了解，具体的解释可以参考[移位运算符的百度百科](https://baike.baidu.com/item/%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/5622348?fr=aladdin)。

 按理来讲二分搜索可以到此结束了，毕竟在改掉了上面这个bug之后这段代码可以说是二分搜索的标答了。但是人类的智慧博大精深，有的时候二分搜索的对象里面并不严格有大小，有的时候二分也并不一定用来找一个数（反正可以用来找一些有特征的任何东西），因此二分搜索也被扩展出了许多版本。关于查找不同特征的二分搜索版本就太多了，这里就不一一列举了，但是对于有重复数字的序列来说，找到重复数字中的第一个/最后一个的方法还是有必要掌握的，这里贴一段找第一个不小于target的位置的代码。
```c++
int lower_bound(arr, first, last, target)
{
  int mid;
  while( first < last )
  {
    mid = first + (last - first) / 2;
    if(arr[mid] < target)first = mid + 1;
    else last = mid;
  }
  return first;
}
```
##### 这段代码的搜索区间是[first，last)
 这是c++标准库中的一个找下界的代码找上界无非就是反过来而已。这段代码不仅简短易读，更可见的好处是容错率高——仅有一处出现了+1的调整，最后return的无论是last还是first都是正确的答案。！！！这种写法非常关键，一定要背下来！！找不同的内容可以在此基础上做变形

 什么？你问我所谓的扩展性在哪里？当然，我既然提到了这段代码怎么可能知识因为他能优雅地解决一个问题呢。恰恰相反，这段代码可以作为很多优雅的功能性二分的原始版本。(以下内容是理解[知乎某优秀答主的回答](https://www.zhihu.com/question/36132386)后自己写的总结)

### 问题一：搜索区间

 上面着重提到，这段代码的搜索区间是左闭右开，为什么要这么强调这一点呢？先说性质,为什么是左闭右开？经过[Dijkstra大佬的论证](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html),这样的搜索区间是最利于判断加减的。暂且就先认为这是我们选择这个区间的理由吧。然后是这个搜索的性质：如果在区间[first,last)里出现了**大于或等于**target的**第一个**数，就返回那个数的下标，否则返回这个区间的**右端点**。所以这里就说明了几个操作：

 * 如果你想把右端点也搜索到的话，你可以把last + 1
 * 如果你想找小于target的最大数，可以用这个方法得到的数 - 1 ，且 -1 意味着没找到
 * 可见取上界的操作是没有必要的(都可以用对应的取下界操作实现)
 * 对于升降序的修改无需改动二分搜索本身，只需要调整if语句里面的判断条件

### 问题二：如何严格地定义搜索条件才不会出错，对该写法拓展性的精妙调整

  大多数时候做二分搜索不会是简单的找不小于某个target的结果，还会有大于、等于、  上面提到了修改if语句中的判断条件即可，为了梳理一遍我当下的思路，以防多年后的某一天我依旧会混淆他们，我决定把这些调整方式做一个简单的罗列：

##### 初学的时候我喜欢把**查找**这个动作分为小于、等于、大于三类，并认为这样的分类是有序逻辑清晰的，直到我弄明白了这次分享的这段源码。其实二分搜索的本质就是在两种结果之间反复横跳——符合条件和不符合条件。所谓的大于小于只是在查找数字的时候所用到的判断条件而已。

* 左边不符合要求，右边符合要求。即找符合要求的下界(~~找上界也没啥意义啊~~)，这就是上面sample的典型情况。把不符合的写在if里面，直接套用代码就没错了！如果不存在返回的就是last的值。

* 右边不符合要求，左边符合要求。那就是找一个上界了。上面提到过，如果你要找上界，最好的办法就是找对立情况的下界，并减去1。**再次提醒：if里面的是不符合的！！，这里找对立，就是把想找的填在里面！！**

* 最后一种也是最普遍的一种——所有上述情况可能发生错误的情况——左右都是不符合的，只有中间是我们要找的。在大多数情况下(要找到东西存在)就是上述的两种情况可以分别找上下界。但是在这种情况下如果找不到是需要特判的，因为返回的不是last的值，而是左右分界线的右边第一个值。所以这种情况下应该找完之后和target比对一下，如果不是target即搜索不到。

### 说在最后的话

以上基本上就是对二分的几个状况的梳理，总的来说二分就是要在搜索条件和搜索范围之间做权衡。可能现在迷迷糊糊的上面的梳理有疏漏的地方，但大体上也就是这么个结构了，如果以后发现有错误再更正吧~~。然而，此时的我意识到dsaa第一次quiz的内容以及超出了这个范围了，于是就有了下一篇的内容，未完待续~
