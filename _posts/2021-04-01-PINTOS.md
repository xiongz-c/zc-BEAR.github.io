---
layout: post
title: pintos实现思路笔记
date: 2021-04-01
tag: OS
---

## Pintos实现思路小记

> 背景：南科大2021春季计算机操作系统课程课程项目一（斯坦福的pintos项目，再额外加了一个小任务）。为了精简起见，此文仅用于记录完成该项目的大致思路。具体的实现代码网上有许多的参考资料，就不在此赘述了。梳理思路的过程中也参考了网上的不少博客，就不一一列举了，感谢大佬们慷慨分享让我得以苟过这次Project...

### 任务

* Alarm Clock 解决忙等待问题
* Priority Scheduling 实现按优先级调度线程
* Multi-level Feedback Queue Scheduler(MLFQS) 多级反馈队列调度
* Test Pintos with GDB [你科新增任务]

### Alarm Clock

pintos原有的sleep策略是忙等待的策略:在sleep的时候cpu不断在就绪队列和running队列之间切换, 直到sleep的时间过去, 这样的话cpu在这段时间就做不了其他事情, 是白白耗费了资源。我们的任务就是把这种等待方式改掉，让线程可以自己判断什么什么时候接触block的状态。分析到这里其实已经很清楚了，我们要做的改动其实就是把查询等待时间这个过程移植到线程本身，或者说不需要cpu切换进线程就可以得到“是否需要解除block状态”这样的信息。

#### 改动思路

把记录阻塞时间的信息存进每一个thread本身，在时间片信息更新的时候遍历thread，将其阻塞时间减一，减到0之后解除thread的组设状态，加入就绪队列执行。

### Priority Scheduling

pintos原有的线程调度形式是先来先执行，而这个部分的任务希望我们把调度的方式升级为按优先级调度。那实际上就是要我们把就绪队列维护成一个优先队列（显然每次选择前排序这种低效的方式不会被考虑）。因此这里最首要的任务就是在线程进入就绪队列的时候放到恰当的位置，使队列保持优先级排列。这里考虑三个地方可能会把线程放进队列：

* thread__unblock 线程停止阻塞的时候
* init_thread 线程初始化出来的时候
* thread_yield 线程调度的时候

找到需要更改的位置之后，我们需要考虑如何更改。 常规的优先队列我们会考虑构建一个二叉堆来实现，但是在这里pintos为了降低难度给我们提供了一个方法`list_insert_ordered` ，这个方法的作用是把一个元素插到链表中的指定位置。这显然就是在暗示我们不需要实现堆，可以按顺序插入线程。这样虽然插入的复杂度没有做到最好，但是也是可以接受的，实现的难度低了不少。

但是仅仅实现了这样一个基本的优先队列并不能通过所有的测试用例，我们还需要考虑一些比较特殊的case

#### 抢占式调度

并不是所有线程在进入就绪队列的时候都是理想的在中间的部分，可能有的线程优先级非常高，以至于比现在正在执行的线程优先级都要高。这个时候就不能让他进来等，必须要让他直接开始执行，让正在执行的线程为其让路。这就是抢占式的调度方式。

##### 改动思路

这个时候要进行的调度方式应该是当高优先级的线程进入就绪队列的时候重新判断优先级关系，把cpu让给当前优先级最高的线程。

#### 可变优先级

线程执行的优先级并不是一成不变的， 很多情况下优先级会随着时间改变，任务会变得更急迫或者不那么紧急。这种情况下只在线程进入优先队列的时候考虑优先级是不够的。

##### 改动思路

这种情况下可以新增一个判断，在线程调用调整优先级的方法时进行判断，重新排列线程的优先级。

#### 优先级捐赠

需要实现优先级捐赠的原因是在线程调度的时候会出现一个问题：低优先级的线程A正在运行并且占据了一个互斥资源，此时有一个高优先级的线程C也需要访问这个资源。但是由于资源的互斥，这个高优先级的线程C无法进入就绪队列被调度，就会被其他线程先运行。如果一直存在一个线程B优先级高于A小于C，B就会被优先执行，从而A不能尽快释放资源，而高优先级的C也不能被执行。

**注意：这里要区分第一种情况。抢占式调度是指高优先级的线程已经进入了就绪队列可供调度，需要抢占cpu执行。但是这种情况下高优先级的线程C并没有进入就绪队列，更不要谈被调度了。**

##### 改动思路

这个问题的出现的根本原因是占用资源的线程优先级太低，我们就需要考虑增加其优先级。但是这个优先级也不能乱加，不能破坏其他无关的线程之间的优先关系。即使出现了资源互斥，依然有优先级更高的线程需要被处理，这个时候肯定不能先执行占据了这部分资源的线程A。所以，实际上线程A的优先级仅仅应该是**所有需要用到该互斥资源的线程中优先级最高的**，这样就不会影响到其他线程的执行，也能保证不影响和自己使用同一个互斥资源的线程的执行。

具体来说，面向测试分析我们的优先级捐赠行为需要满足以下几种情况：

* 在一个线程获取到一把锁之后，如果此时拥有这个锁的线程优先级比自己的低，就提高其优先级。如果这个锁被其他锁锁住了，就递归地增加对应线程的优先级。在释放锁的时候恢复锁的优先级为原有的优先级
* 如果一个线程被多个线程进行了优先级捐赠，应该维持当前的优先级为目前最高的优先级。
* 对于多个线程，如果捐赠目标的优先级已经被捐赠了，要分情况考虑。如果对方的优先级比自己高，不用处理。否则应该捐赠优先级并在释放锁的时候降到目前的优先级(而不是最原始的)。
* 释放锁改变优先级的时候应考虑其余被捐赠的优先级和当前的优先级( *以上三点说的是一件事* )
* 将信号量的等待队列实现为优先级队列
* 将condition的waiters队列实现为优先级队列
* 释放锁的时候若优先级改变则允许抢占

### MLFQS

这个任务需要我们实现多级反馈调度。

> 多级反馈调度：构建多个就绪队列，并根据优先级排列。调度的原则是优先调度优先级高的队列，优先级高的队列没有任务才调度优先级低的队列。但是调度的过程不能让其完全调度完，而是只运行一定的时间片。优先级越高的就绪队列分配的时间片越少。每个任务进来时先进入优先级最高的队列，执行完这个队列分配的时间片之后，如果任务还没完成，就会进入下一个优先级的队列，循环直至完成。这样可以一定程度上防止低优先级的任务的饥饿问题。

这个Task的逻辑并不复杂，只需要维护64个队列，并通过一些公式计算出每个队列的优先级（因为这个优先级是随着系统运转动态改变的）。

#### 改动思路

具体的实现逻辑是在`timer_interrupt`函数中按固定的时间段动态计算更新线程的优先级。这里的逻辑是每**TIMER_FREQ**时间更新一次系统**load_avg**和所有线程的recent_cpu， 每4个**timer_ticks**更新一次线程优先级， 每个**timer_tick** running线程的**recent_cpu**加一。这里如果要mlfqs的话其实就不需要之前提到的优先级捐赠了，这是两种不同的调度方式。在前面的优先级捐赠里面增加一个判断即可。

### Test Pintos with GDB 

这个是学校抄完斯坦福的Project之后新增的一个小任务：用gdb找到pintos的bug并修复。 这里的bug其实是小数计算的精度问题，大多数人可能懒得使用GDB看代码的时候也已经发现了这里可能存在问题。稍微交换一下计算的顺序就能修复这个问题了，就不细琐了。

