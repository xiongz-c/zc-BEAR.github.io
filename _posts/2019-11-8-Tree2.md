---
layout: post
title: 第一次接触非线性结构——树的入门(二)
date: 2019-11-8
tag: algorithm
---

因为发现上一节的内容有点多，所以把一些特殊的树和一些更重要的扩展知识放在了这一节来讲。两节放在一起才是完整的树这个部分的总结。

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### 临时小目录：记录这一章要讲些什么
 
* ~~树的基本操作：结构、遍历求深度(DFS，魔改DFS)~~
* 树的性质：重心、直径
* 二叉树：基础树结构、递归遍历，非递归遍历，前中后序遍历转换，性质，应用
* 哈夫曼树：应用，构建哈夫曼树，求加权和【构建/使用优先队列】

### 二叉树：最常用的一种树结构

正如标题所说，二叉树是最最常见的树了，这种结构有着一些很好的性质，可以在一些地方有巧妙的应用。以下是来自[维基百科](https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91)的关于二叉树的定义：

> 二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根节点的度不大于2。有了根节点之后，每个顶点定义了唯一的父节点，和最多2个子节点。然而，没有足够的信息来区分左节点和右节点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。

其实很简单，二叉树就是每个节点至多只有两个子节点的树，是树的一种特殊形式。在C++中他的基本结构是这样的：

```cpp
struct TreeNode
{
    int elem;
    TreeNode *leftchild = nullptr;
    TreeNode *rightchild = nullptr;
};
```

#### 二叉树的遍历

上一节提到过，二叉树的遍历相比于普通的树多了一种中序遍历，这是由于二叉树只有两个子节点的特殊性造成的。这里简单罗列一下三种顺序的遍历吧

```cpp
void Traverse(TreeNode root) {
        if (root != null) {
            //do sth    preOrder
            Traverse(root.left);
            //do sth    inOther
            Traverse(root.right);
            //do sth    postOther
        }
}
```

以上是递归版本的遍历顺序。除此之外，遍历还可以用while循环加上栈的结构来实现，在栈深有限制的情况下可以避免使用递归。可惜代码还没有自己写过，就不贴现成的代码了，有机会等自己写过一遍了再把代码放上来。

```cpp
//未来可能会有的代码
```

**人生苦短，证明就免了吧——Gilbert。**

以上的遍历代码都是对的！我就不想证明了，也没有什么证明的必要，往后再讲讲更多的性质吧。

#### 典例：前中后序遍历的转换——已知中序的情况下可以知二推三

为了更好的偷懒，这里就不多讲解原理了，直接丢出作业题吧[DSAA Lab6_C fall 2019 autumn](https://acm.sustech.edu.cn/onlinejudge/problem.php?cid=1058&pid=2)。这道题给出了前序和中序输出的二叉树，希望我们得到这棵树的后序输出。没有看出这道题有什么原理可讲，也就直接当这道题是一道结论题，给出递归部分的结论代码吧。

```cpp
void find(int low1,int high1,int low2, int high2){
    if(high1<low1 || high2 < low2)return;
    int root = -1;
    for(int i = low2;i <= high2;i++){
        if(ino[i]==pre[low1]){
            root = i;
            break;
        }
    }
    if(root == -1)return;
    find(low1+1,root-low2+low1, low2, root-1);
    find(root-low2+low1+1,high1, root+1, high2);
    cout<<ino[root]<<" ";
}
```

因为中序输出总是在中间输出根节点，而前序输出第一个输出的就是根节点，所以只要在**中序输出的序列**中找到**前序序列的第一个节点**，这两个位置中间的部分即是根节点的半个子树。不断地进行这个递归的过程就可以得到最末端的节点，所以把打印放在递归的最后。至于为什么这样做就会打印出后序的输出，我也没能很好地理解，暂且当一个结论记住吧。

再加一嘴，如果已知后序和中序是否可以从后往前找第一个和中序的节点呢？然而我并没有尝试过，仅供参考的思路。

#### 二叉树的一些重要性质

### 哈夫曼树

哈夫曼树，又叫最优二叉树。从定义上来说，就是一个加权和最小的二叉树(权值即节点的值)。这也是一个解决最优化问题的很好方法。

#### 构建哈夫曼树的思路

手写哈夫曼树，是一个理解哈夫曼树的重要过程。以下是手写哈夫曼树时的步骤

> 首先对需要构建哈夫曼树的数组进行排列，再选出头两个加和

> 把加和后的结果放回数组中恰当的位置，再选出最小的两个数进行加和。即构建出一棵棵小树形成森林又合成了一棵大树。

#### 应用：哈夫曼编码

### 求哈夫曼树的加权和——优先队列的应用

可是在很多的情景下，我们只是需要用到哈夫曼树的一些性质，并不需要把整个哈夫曼树构建出来，往往只需要把他们的加权和求出来。从前面的构建过程很容易可以看出每个被加和的结果加起来就是最小加权和。

这个时候你就会想，如果有一种结构，能够每次把最小的两个值pop出来该多好！幸运的使，这样想的当然不止你一个人，于是就有了一种很实用的数据结构：优先队列。

#### 优先队列的结构

优先队列一般使用堆来构建(插入复杂度为O(logn)，初始化复杂度为O(n)),也有另一种构建方式为使用平衡二叉查找树(插入复杂度为O(logn)，初始化复杂度为O(nlogn))，显然前者更优。

大概的构建思路就是先把数组整理为一个二叉堆，然后每次插入删除的时候把元素位移到合适的位置即可，具体的实现想起来再补到这一块吧。

#### 但是!C++和Java都是有自带的优先队列的

显然，数据结构的考试种并不会让你手写优先队列，即使要你手写你也不会有时间写好的，这时候性价比更高的方式就是更好地了解优先队列如何使用。优先队列的声明的基本格式如下：

```cpp
priority_queue <数据结构> name;
```
我们平时在使用优先队列的时候，会遇到需要更改的情况无非两种：最大还是最小、使用哪种数据类型，因此，一般情况下有以下几种声明方式：
```cpp
priority_queue <node> q;//使用node结构体，可以重载比较函数

priority_queue <int,vector<int>,greater<int> > q;//从小到大
priority_queue <int,vector<int>,less<int> >q;//从大到小
//注意两个> >不要放在一起，会被当成>>编译
```
### 小总结

以上是关于基础树结构的一些知识和技巧的小回顾，也是被这周低级树lab摩擦之后觉得树里面可能有的考点。马上就要迎来两周DDL的大Lab和死亡期中考了，下周如果对树的了解可以更深一步，将会把相关的内容更新在这两章博客种，也有可能另起一章讲讲更多的树结构，此章到这里就暂时告一段落啦！