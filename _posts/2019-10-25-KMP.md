---
layout: post
title: 字符串匹配的先进算法——KMP及其扩展
date: 2019-10-25
tag: algorithm
---

  经过了DSAA的恶魔quiz后，我们终于来到了本学期(可能)最难的算法——KMP字符串匹配算法的学习，期中考试也即将到来，因此本章的内容主要是讲解该算法及期中考前回顾。这次没啥废话想讲的，直接进入正题吧。

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### KMP匹配详解

  直接进入第一部分的内容，KMP字符串匹配算法。科普知识详见[维基百科](https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm)。

#### 字符串匹配：为什么我们不采用朴素算法？
  
  实际生活中，想要匹配两个字符串是否相等的场景十分常见，如何高效地判断两个字符串是否相等也成了大家十分关心的问题。说到字符串匹配，你脑子里一定有一个最最简单显然的思路：

  > 对于给定的长度为n的字符串a和长度为m的字符串b，如何判断b是否完整地出现过在a中？
  > 从a的第一个字符开始匹配，如果ab对应的字符相等，就继续匹配下一个，如果不相等，就回到a的第二个字符位重新匹配。

  显然这样做是十分低效的，如果你每次都匹配到b的最后一个字符串才失配，要足足匹配m*n次才能得到结果，复杂度太高了。那问题是出在哪里呢？直观地想一下，每一次字符串的失配都要回溯两个字符串已匹配的下标i和j，而事实上前面有一些已经匹配过的片段中是可以判断是否能继续匹配下去的，即这个i的回溯是没有必要的。换句话说，这个搜索匹配的过程是可以缩减到O(m)或O(n)的级别上的。这个简化的过程就是接下来要讲到的KMP算法将要进行的操作，我们也称其为最大相同前后缀的维护。


#### KMP算法的核心部分，用于记录最大相同前后缀的NEXT数组

  这次不打算先把代码简单粗暴的放在第一个位置，因为从我的学习经验来看直接看完整代码并不能很好地帮助我理解KMP算法是个什么东西，这次我的做法是把这个算法拆解，先从最精妙的部分讲起——这个求NEXT数组的过程。NEXT数组是什么呢？这是一个作用于**字符串b**的数组，数组里面包含的信息是“b串中最前后最后相匹配的字符串长度”，但显然不是直接地把字符串长度放在数组里，而是将经过了一定的简单处理后**便于进行kmp匹配的数值**放进了数组。先看看以下代码吧，这份求NEXT数组的代码出自[v_JULY_v 前辈的博客](https://blog.csdn.net/v_july_v/article/details/7041827) 

```c++
void GetNext(char* p,int next[])
{
  int pLen = strlen(p);
  next[0] = -1;
  int k = -1;
  int j = 0;
  while (j < pLen - 1)
  {
    //p[k]表示前缀，p[j]表示后缀
    if (k == -1 || p[j] == p[k]) 
    {
      ++k;
      ++j;
      next[j] = k;
    }
    else 
    {
      k = next[k];
    }
  }
}
``` 

  还有另一种求next数组的写法，即开头第一位不是-1而是0，每一个数字对应的next即是对应的相同前后缀。其实从本质上来说这两者没有任何区别，只是在用到前后缀长度的时候用另一种写法更自然，而用到KMP的时候这种写法可以不用考虑next的加减问题。**值得一提的是，再用这种求法时如果遇到了前后缀最大值的问题，可以在字符串的最后加上一个结束符，再求next数组。这样求完之后结束符的位置就会对应相应的最大重复前后缀，保证next的信息不丢失。**

### KMP的部分

  同样地，附上同样来自于JULY前辈的KMP匹配部分的代码。

```c++
int KmpSearch(char* s, char* p)
{
  int i = 0;
  int j = 0;
  int sLen = strlen(s);
  int pLen = strlen(p);
  while (i < sLen && j < pLen)
  {
    //①如果j = -1，或者当前字符匹配成功（即S[i] == P[j]），都令i++，j++    
    if (j == -1 || s[i] == p[j])
    {
      i++;
      j++;
    }
    else
    {
      //②如果j != -1，且当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j]    
      //next[j]即为j所对应的next值      
      j = next[j];
    }
  }
  if (j == pLen)
    return i - j;
  else
    return -1;
}
```

  使用这套板子最重要的原因就是它写的太易懂了，再这个while循环中匹配和失配的分类讨论，失配时i不作移动j移动到next[j]的位置，匹配时大家一起向后移动，每次移动都判断一下j是否到达终点，最后返回的是匹配成功的第一个字母的位置或者-1表示匹配失败。

  代码的部分就是这么多，剩下要做的事情就是把这段代码背下来！是的，KMP的理解难度主要是在于求next，如果看了几遍之后明白了next的如何取后就是对next进行一个有限状态自动机的操作，所以说KMP匹配就是有限状态自动机的一个特例。

### 自动机是什么

##### 说在前面的话：KMP的简单总结结束了，复习资料的博客不会有太多的讲解，主要把要背下来的东西罗列了一下。这里在花点时间讲一下自动机，自动机在DSAA这门课中应该不会设计得太多，其中遇到的问题应该都可以用KMP来解决。但是作为KMP算法更高一个层次的东西，各种自动机在算法比赛中会有比较多的应用，这里就依据我现在的理解简单讲一下自动机是什么吧。

 自动机，又叫有限状态自动机(DFA)。概括地说，就是一个已经被安排好了的“状态表”，这个状态表在接受特定的结果会做出特定的反应。没错，这里要举的例子就是next数组。KMP算法的next数组部分就可以算是一个自动机，因为先对匹配字串做了预处理，得到了每一个字符的next位置在哪，在每次接受字符串时这个自动机就会做出两种状态的判断：进入下一个 or 进入next位。从而完成状态的转移，状态到达len的位置时就是自动机判断结束的时候。

 那么，自动机有什么用？好的，我也不知道。此博客结束。