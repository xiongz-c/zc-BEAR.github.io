---
layout: post
title: 第一次接触非线性结构——树的入门
date: 2019-11-8
tag: algorithm
---

  期中考试时间为11月九号上午十点到十二点，考试内容为第一章到树讲完的内容。本章博客会在考试前一个星期持续更新，记录树结构的相关知识。

##### tips：虽然本人用JAVA更熟练，但是考虑到算法题中大多使用C++来实现，并且我也在龟速学习C++，这个标签下的代码都是C++代码。

### 临时小目录：记录这一章要讲些什么
 
* ~~~树的基本操作：结构、遍历求深度(DFS，魔改DFS)~~~
* 树的性质：重心、直径
* 二叉树：基础树结构、递归遍历，非递归遍历，前中后序遍历转换
* 哈夫曼树：应用，构建哈夫曼树，求加权和【构建/使用优先队列】

### 树的基本概念与操作

 树是一种没有环的图。相比于诸如“树是一种形如树状的数据结构”之类的废话定义，我更喜欢这样定义树。虽然这不是一个准确定义树结构的方式，但是这说明了树的一些性质是和图有所关联的。在考虑树的一些问题时，往往与图的问题有一些相关性。同时，这也说明了，从树开始，我们就要不断地和递归、递归、递归打交道了。各种递归的方式将是我们遍历树图的工具，从这里走进树结构吧。

 树有一些基本的名词定义如下,来自[维基百科](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))：
>节点的度：一个节点含有的子树的个数称为该节点的度；
>树的度：一棵树中，最大的节点度称为树的度；
>叶节点或终端节点：度为零的节点；
>非终端节点或分支节点：度不为零的节点；
>父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
>兄弟节点：具有相同父节点的节点互称为兄弟节点；
>节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
>高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
>堂兄弟节点：父节点在同一层的节点互为堂兄弟；
>节点的祖先：从根到该节点所经分支上的所有节点；
>子孙：以某节点为根的子树中任一节点都称为该节点的子孙；
>森林：由m（m>=0）棵互不相交的树的集合称为森林；

 以上是开始聊树结构之前必须知道的一些名词，至于其他各种各样奇形怪状的树名和性质就等到遇到了在慢慢了解吧。

#### 树的结构
 
 正如本文标题所说，树是我们接触到的第一种非线性的结构，因此构造树的节点的时候我们很容易联想到不久前学过的线性结构——链表。从链表的结构来推断，树的结构可以用如下代码表示

```cpp
struct node
{
	int val;
	node *leftchild = nullptr;
	node *rightchild = nullptr;
};
```

 这是一种比较典型的二叉树结构的C++描述，如果替换为有更多子节点的树，可以使用vector存取子节点，存取也方便。但是在实际的应用中，很多时候题目并不需要来构建一个树结构来解，像是作业中更多的时候是使用**array+vector**的形式模拟一个树的实现，就像之前在链表中实现的数组拟链一样。模拟出来的树和真实的树有所不一样的是，所有树的边两边的node都是等价的，即子节点也可以向上追溯到父节点的。这就在遍历的时候造成了一定的麻烦——区别这个节点究竟是父节点还是子节点，这就是我们要谈到的树的遍历。

#### 树的递归遍历：前后序

 **Attention：所有的递归都会用到大量的空间，在递归做题时注意是否爆了空间或者说开的栈的深度是否足够！**

 树的遍历是一种解题的手段，用不同的遍历方式可以以不同的顺序对节点进行操作，这是递归遍历的意义所在。而对于一般的树来说，遍历一般分为前序遍历后序遍历、深度优先遍历、广度优先遍历等(二叉树还拥有特殊作用的中序遍历，后面会提到)，其中比较简单的前序遍历后后序遍历即是在递归前和递归后对节点进行相应的操作，基本实现代码(以内容为整数为例)如下：

```cpp
void search(int fa, int me){
	//在这里进行操作即为前序遍历
	for(int e : v[me]){
		if(e != fa){
			search(me,i);
		}
	}
	//在这里进行操作即为后序遍历
}
```

 简单地理解一下前后序遍历的不同。其实他们访问节点的顺序是一样的，但是前序遍历是在访问到节点之后就立即进行操作，但后序遍历是一直向下找到尽头时才开始操作。如果把这个操作打印出来，就会体现为从上到下的遍历和从下到上的遍历之间的区别，具体的图片就先不贴了，写几遍去百度上找几篇博客对一下基本是没有什么问题的。那么这个遍历一般可以用于进行什么操作呢？作为基本的遍历形式，几乎所有的题目都会有相关这两种遍历形式的遍历。问题的关键是何时用哪一种顺序的遍历，这主要取决于你希望进行的操作是什么。

* 一般来说，当你计算一些值需要用到父节点的值时，就必须在递归下去之前先把这个值记录了才能做到累加，可惜暂时想不到什么例题。
* 同样的，如果你需要先得到子节点的值时你就不得不用后序遍历，如DSAA作业题中的Lab6_E，通过子树的红蓝点推断自己的红蓝点数量。

#### 树的递归遍历：魔改大法师

 DFS(深度优先遍历)，一个在JAVA1的作业和project中就用到的遍历算法，在DSAA中又被拿出来摩擦了一遍。希望这次自己有一个更深的理解。要想理解DFS，第一步就是摒弃死记硬背。DFS只是一种思想——向符合条件的位置进行递归搜索直到不符合为止。至于你在这个搜索的过程中干什么，都是属于可以自定义的部分。所以在DFS中，只要记住操作和递归条件自定义，就可以改出无数种适合题目的DFS方式，这里贴出一个作业题的深度优先搜索的正确代码。

```cpp
int find(int fa,int me, int cnt){
    cnt++;
    c[me] = cnt;
    if(nodes[me].empty())return cnt;
    int tmpC = cnt,mcnt = cnt;
    for(int i : nodes[me]){
        if(i!=fa){
            cnt = find(me,i,tmpC);
            if(cnt>mcnt){
                mcnt = cnt;
            }
        }
    }
    return mcnt;
}
```

 这是一种难度中等比较常见的深度搜索范例——在不知道子节点数量的情况下进行深度优先的查找。这里的深入条件就是只要有子节点就可以深入，但是只有子节点让cnt增加了才更新mcnt。可以看到这份代码并不是很优雅，因为对mcnt的更新完全没有必要，这里只要在递归的时候记录下每一个节点的深度，递归完成后做一个遍历，就可以找到最大深度，完全没必要绞尽脑汁去想怎么写才能返回最大的深度，如果要做出更改，大概就是这个样子：

```cpp
void find(int fa,int me, int cnt){
    cnt++;
    c[me] = cnt;
    if(nodes[me].empty())return ;
    for(int i : nodes[me]) if(i!=fa) find(me,i,cnt);
}
```

 这样就舒服多了，这也告诉我们，在进行DFS时，把精力放在可以搜索的**最宽松的条件**上，找最大值时可以通过各种条件筛选出符合条件的最大值，才是最优雅的深度优先搜索的实现，而不必要在思考如何正确地返回你想要的最大值上绞尽脑汁。

### 树的性质：重心、直径、等等